# Software Design Document (SDD)

:::caution

This document is actively being worked on so expect gaps.

:::

## Purpose

This document details the current state of the design of the Aerie system. The document defines the components which make up the Aerie system and how these relate to the higher level architecture description document. Additionally, design rationale and the trade studies are described to provide guidance and support for design decisions. Where available the many Aerie component interface definitions and relevant published Software Interface Specification documents will be provided inline or referenced.

## Overview

Aerie is a software system being developed by the MPSA element of Multi-mission Ground System and Services (MGSS), a subsystem of [AMMOS (Advanced Multi-mission Operations System)](https://ammos.nasa.gov/). Aerie will support activity planning, sequencing, and spacecraft analysis of mission operations. This document will be updated as further aspects of the design are completed.

## Terminology and Notation

- **Container** – in this document the term container primarily refers to the Container level of architecture as defined in the [C4 Model](https://c4model.com/) approach to describing software architecture. Other types of container, such as a Docker container, will be denoted or made clear by context.

- **Mission model** - The term "adaptation" has become significantly overloaded at JPL. The word is used in many different contexts to convey or denote a range of different and often unrelated entities or concepts. Often, the ability of one to understand the entity or concept which term denotes, relies on one’s ability to understand the wider context in which it being used. This requires a burdensome amount of understanding of the domain before the term becomes specific and useful. Additionally, the boundary or extents of what the term denotes is unclear. Take for example the commonly termed mission planning adaptation. On first mention, it is not clear here if such usage indicates the specific APGen code written, or wider, the APGen code plus any modeling integrations, or wider still, the integrated system which performs a MP simulation. Finally, this term is very JPL centric and does not comport with other language in the domain of modeling, simulation, discrete event simulation etc.

  As a result Aerie has chosen to use the term mission model to denote the modeling code (and integrations e.g. FMU) written, defined in a [.JAR](https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jarGuide.html), which run as an Aerie simulation. It's specific as to the purpose of the code written, unambiguous (not confused with other terms in use), and better comports to the domain of simulation and modeling in general.

## References

Table 1: Applicable JPL Rules Documents

| Title                          | Doc ID |
| ------------------------------ | ------ |
| JPL Software Development Rules | 57653  |

Table 2: Applicable MGSS Documents

| Title                                                 | Doc ID     |
| ----------------------------------------------------- | ---------- |
| AMMOS Technical Standards Profile                     | DOC-001101 |
| MGSS Implementation and Maintenance Task Requirements | DOC-001455 |
| Aerie Software Requirements Document (Aerie SRD)      | DOC-002388 |
| Aerie Product Guide                                   | DOC-002537 |
| MGSS Implementation and Task Requirements             | DOC-001455 |

## Allocated Requirements

Please refer to the Aerie Software Requirements Document referenced in Table 2.

## Design Context / Principles

[TODO]

The following provides a summary discussion of the reasoning behind the Aerie architecture. This section will detail the design's guiding principles, assumptions, and constraints.

An incremental/evolving potential in the design. The component based system design provides the benefits of component based [LIST THESE BENEFITS]. In the case where application need to accommodate growing or new capabilities, where those new capabilities are satisfied by separating a component into its own process, this can be done. A well designed monolith in many ways should resemble a distributed system. This means one should avoid shared state, strict definition and adherence to interfaces a service interface is equal to a component’s exposed interface. A message passing reactive system can exists whether the components are in the same process, in separate processes, or even separate infrastructure.

[Discuss Bounded Contexts and their definition/extraction from the domain model]

For example the [merlin-worker](https://github.com/NASA-AMMOS/aerie/tree/develop/merlin-worker) is a part of the Merlin bounded context. Much of Aerie has been designed with the [DDD principle of bounded contexts](https://martinfowler.com/bliki/BoundedContext.html). Among the many implications of this is that the data within each bounded context shall only be manipulated by the components explicitly contained within the defined context. It is important not to mistake the fact that the merlin-worker is a separate container image as indicating that it is part of a separate bounded context. Rather, it is simply a separate container so that the merlin-server can account for the aforementioned process separation concerns. Therefore, each merlin-worker has a direct connection to the merlin database.

## Aerie System Design

### System Architecture

This section describes the Aerie system architecture, the guiding component-based design philosophy, and an overview of the key components.

The architectural diagramming approach taken in this document follows the C4 Model for visualizing and discussing software architecture. This approach abstracts a software system into roughly four levels, Context, Containers, Components, and Code. A brief description of each level of abstraction is provided in [Appendix A](#a---the-c4-model).

import c4AerieContext from './assets/c4-aerie-context.png';

<figure align="center">
  <img alt="Aerie Context" src={c4AerieContext} width="512" />
  <figcaption>Figure 1: Aerie Context</figcaption>
</figure>

- [TODO] Update to discus the fact that a component focused approach will satisfy Aerie's needs.
  Aerie's load needs aren't addressed by spinning up many instances of a service (horizontal scaling)
  Discuss why this leads to a design: is appropriately extensible and key points for needed modularity

### Container Level Component Overview

import c4AerieContainer from './assets/c4-aerie-container.png';

<figure align="center">
  <img alt="Aerie Container" src={c4AerieContainer} width="700" />
  <figcaption>Figure 2: Aerie Composition at the Container Level</figcaption>
</figure>

- **Merlin Server** - Capabilities, plan management, manages the simulation and configuration of a mission model, manages simulation results, constraints management and resolution.

- **GraphQL Gateway API** - The GraphQL gateway parses requests and resolves those requests with application internal components. The gateway is implemented via [Hasura](https://hasura.io/).

- **Aerie UI** - The server provides a user interface which supports the myriad management and analysis processes performed during mission planning and mission operations. The server manages data regarding an individual user’s view layouts and selected user interface preferences.

- **Common Access Manager (CAM)** - Aerie delegates authentication and authorization capabilities to an MGSS Common Access Manager server. Customers deploy their and configure a CAM to provide authentication and authorization of mission personnel.

- ~~**Common Logging Service (CLS)** - Aerie system level logging can be routed to a customer preferred log collection component. A default Aerie deployment assumes that system wide logging will be reported to a customer deployed instance of the MGSS Common Logging Service (CLS). A CLS instance provides a set of analysis and dashboard tools to monitor an Aerie deployment.~~

- **Automated Scheduler** - An automated scheduler operates external to the Aerie deployment and carries out computer aided mission activity scheduling by issuing queries and mutations against the Aerie GraphQL API. As a component external to the Aerie deployment, an automated scheduler can be developed by a customer in their preferred programming language and executed on infrastructure most suited to the computational needs of their scheduler’s algorithmic approach.

### API

The Aerie GraphQL API presents a consistent application boundary to Aerie users. The API server enables the composition of multiple APIs (internal to the application) as a single API endpoint. The API component additionally provides a location in the system for the following needs:

- Manipulation of data
- Response Caching

#### Aerie API Needs

1. Evolve the internal APIs rapidly and the public APIs slowly.

   The development of the Aerie user interface and application internal components proceeds in parallel. As a result, the user interface’s data needs imposes constraints on the definition of the system’s public API. The evolving nature of the user interface’s development makes it difficult to carry out an API design effort, as would be the case for a REST API architectural style. Further, the structure of resources needed by the highly configurable interface components within the user interface, makes defining an efficient set of resource endpoints prohibitively difficult. Such endpoints would require continuous editing and updating as development progressed.

1. Multiple clients and multiple different workflows for clients.

   There exists a category of use cases in which customers develop custom Aerie client applications. Such customization requires the flexibility to easily define new data projections as simple queries constructed by a client. As a result, Aerie benefits from an API that supports high query flexibility from both the external client and internal services perspective.

1. Ability to dynamically reduce/transform response payloads.

   Within the planning, scheduling and sequencing domain are a number of common list like data structures/concepts which are often quite large in size (number of elements). It is inefficient to impose upon any client seeking a particular view/aspect of the data structure to request and process the entire structure. For example, certain resources can’t be made "smaller" without compromising their intent. A Plan can be filtered but not sensibly partitioned. It is desirable that any client requesting such data structures be provided with an easily accessible means to query the data structure for the elements/projection of interest.

1. Custom queries and batch fetching.

   The Aerie stores a number of significant mission data sources (E.g. activity plan, simulation results, and constraint violation results). Aerie must provide users flexible access to this data to support an arbitrary space of use cases for reporting, auditing and interfacing with third-party customers.

#### Trade Study

A trade study was conducted to evaluate available API products. A down selection of the tools left both the [Tyk API](https://tyk.io/) gateway product and [Apollo GraphQL Server](https://www.apollographql.com/) product. The primary difference between these two products are their approach to exposing data. The Tyk gateway exposes system queries as [Representational State Transfer (REST)](https://www.codecademy.com/article/what-is-rest) endpoints while the Apollo GraphQL server exposes a single GraphQL query endpoint. The REST and GraphQL architectural styles present different approaches and embody contrasting capabilities. Representational State Transfer is an architectural style for distributed hypermedia systems. GraphQL is a query language for an API, exposed as a typed schema defined by a data graph. Table 3 presents a set of desirable API properties and the manifestation of each property for REST and GraphQL driven APIs.

Table 3 Comparison of REST and GraphQL capabilities

| System Property                                    | REST    | GraphQL            |
| -------------------------------------------------- | ------- | ------------------ |
| Modifiability                                      | ✅      | Runtime inspection |
| Scalability                                        | ✅      | ❌                 |
| Portability                                        | ✅      | ✅                 |
| Reliability                                        | ✅      | ✅                 |
| Simplicity                                         | ✅      | ✅                 |
| Visibility                                         | ✅      | ✅                 |
| Performance                                        | ✅      | ❌                 |
| Discovery and Introspection                        | Limited | ✅                 |
| Consistency                                        | ❌      | ✅                 |
| Ease of Server Development                         | ❌      | ✅                 |
| Ease of Client Development                         | ❌      | ✅                 |
| Over-fetching protection without proper API design | ❌      | ✅                 |
| Active Community                                   | ✅      | ✅                 |
| Tooling Server                                     | ✅      | ✅                 |
| Tooling Client                                     | ✅      | ✅                 |
| Tooling API Management                             | Limited | ❌                 |
| Maturity                                           | ✅      | ❌                 |
| Works with any data representation                 | ✅      | ❌                 |
| Printed Books                                      | ✅      | ✅                 |
| Enterprise Ready                                   | ✅      | ✅                 |

The following is a discussion of the particular API qualities which provide for Aerie’s needs.

- **Discovery and Introspection** - The GraphQL data graph schema provides a contract-like mechanism where requests and replies are inherently typed and can be directly validated and resolved based on those types. This contract like nature completely describes all possible requests/responses where a typed service provider won’t compile until it fully implements its contract. A typed service consumer will be type-checked at compile time, which helps to catch problems before deployment. Finally, it is unreasonable to expect that a well-performant API can be developed for every conceivable use case. As a result the improved introspection at the per field level in GraphQL allows for targeted optimization of common or slow queries.

- **Consistency** - The API schema is typed and therefore either correct or not. As a result, there is an inherent consistency between client and server because both must abide by the generated schema.

- **Ease of Server Development** - It is easier (development time, complexity) to develop and maintain data source resolvers as part of a GraphQL server. Well designed, true REST APIs take time and resources and are therefore more difficult to design and maintain. GraphQL relieves the project of that unnecessary burden.

- **Ease of Client Development** - A client can develop against the exposed contract. A client can develop custom queries targeted to its own use cases to limit both over and under fetching. In many cases this may reduce latency and increase performance by limiting client side data manipulation/filtering.

- **Flexibility of API Design** - User and mission needs are constantly evolving. GraphQL decouples the API allowing the Aerie team to make adjustments to the API according to evolving customer needs. Additionally, the increased granularity and visibility when auditing the frequency and combinations with which certain fields are queried, allows for clearly validated deprecation, removal, and changes of fields available in the API schema.

By adopting GraphQL we knowingly forgo certain capabilities/constraints of a REST API. Three cases have been identified as possible risks and sufficient mitigation options are identified:

1. **Tooling API Management** - GraphQL is a newer technological approach to APIs (2012).<br />
   **Mitigation:** Aerie has chosen to use Hasura, a major open source contributor to the GraphQL community.

1. **Caching** - REST over HTTP benefits from existing HTTP server caching and browsers client caching mechanisms.<br />
   **Mitigation:** Most GraphQL libraries have caching mechanisms built in. Hasura caching must be handled with annotations/directives on the graph definition.

1. **Client-API Loose Coupling** - Each new client application must make affordance at development time and hardcode custom queries and mutations as made possible by the Aerie GraphQL schema.<br />
   **Mitigation:** None. In the Aerie context this is not considered a benefit.

### Merlin Server

The Merlin server supports the following capability areas:

1. Mission model management
1. Plan management
1. Simulation execution and results management
1. Constraints management and evaluation

There are two driving user stories which help define the core business logic of the Merlin server. The two user stories are:

1. A user wants to create and edit an activity plan.
1. A user wants to view the mission resource profiles of a simulated activity plan.

By providing for these two user stories the Merlin server is able to support many other more complex user stories.

The Merlin server component diagram is show in Figure 3. There exist strong data coupling between the data contained in a Plan and the data defined in a mission model. To reduce the potential for significant data model duplication and intra container communication the server is designed as a single entity.

The Merlin server is implemented as a Javalin application. Javalin is a lightweight web framework implemented as a layer atop Jetty. The underlying Jetty server is fully configurable, providing SSL and HTTP2 capabilities. Javalin was chosen because it focuses only on providing a web application framework, it's simple to integrated, and demonstrates satisfactory performance (performance of raw Jetty code). Compared to the myriad other web application frameworks, Javalin is extremely simple in its implementation and use. The Aerie project has chosen not to use frameworks such as Spring, due to their steep learning curves, lack of focused capabilities, and burdensome dependencies and size.

The App component defines the configuration of the Javalin server and resolves calls to the Merlin server HTTP API to response handlers provided in the Plan Logic and Mission Model Logic components. The Plan Logic component encapsulates the business logic for managing and manipulating activity plans. The Mission Model Logic component manages mission models, simulation of those models, and the queries regarding results (resource profiles and constraints). The Mission Model Facade defines a set of queries that can be made of a mission model. These queries pertain to both, data defined by the mission model (activity types and resources), and data generated by simulating the mission model (resource profiles and constraint windows). The facade orchestrates the loading of a mission model, and makes transparent to the Mission Model Logic, the execution of a simulation by the Simulation Driver.

[TODO: List the Merlin components and describe the interface and separation of responsibilities between each.]

Both the Plan Logic and Mission Model Logic components read from and write to a single PostgreSQL database instance. The database maintains separate tables for each of the components. The Mission Model Logic stores the JAR files defining mission models in a file system.

import c4MerlinServerComponent from './assets/c4-merlin-server-component.png';

<figure align="center">
  <img alt="Merlin Server Component" src={c4MerlinServerComponent} width="700" />
  <figcaption>Figure 3: The Component Diagram for Merlin Server</figcaption>
</figure>

### Merlin Workers

The merlin worker component introduces a multi-tenancy capability for Aerie simulation. The driving use cases for the merlin worker architecture are:

1. Executing multiple concurrent simulations
   - Aerie is a multi-user application and needs to be able to execute multiple concurrent simulation requests.
1. Separate process spaces to provide
   - Protection against SPICE's non-thread safe implementation.
   - The ability to reduce simulation time by executing simulations on computationally performant hardware, while running other Aerie components on more modest infrastructure.

Firstly, it is clear that threading concurrent simulation requests could have been a viable first step on the path if the SPICE library was thread safe. SPICE is not thread safe and therefore each library loaded in a process must be accessed by only one thread.

Secondly, simulation execution is the most computationally expensive process among the various Aerie components. While Aerie in general can be deployed to generally powerful compute resources, it is more cost efficient to deploy only the compute bounded portion of the process to dedicated compute resources. Separating out (decoupling) the merlin-worker's responsibilities into a separate process enables Aerie to be deployed across a number of hosts, where the merlin-worker containers are deployed to infrastructure tuned for simulation execution speed and the remainder of containers on modest hardware.

The worker subsumes the responsibility of running a simulation and writing the results to the merlin postgres database. The merlin-server processes a simulation request, creates the initial dataset tables and associations. The simulation_dataset entry is initially set with a status "pending". This status indicates that the simulation run is queued waiting for a worker to take the job. When a worker takes the job the status is updated (by the worker) to "incomplete".

The merlin-worker is a part of the Merlin bounded context. Much of Aerie has been designed with the DDD principle of bounded contexts. Among the many implications of this is that the data within each bounded context shall only be directly mutated by the components explicitly contained within the defined context. It is important not to mistake the fact that the merlin-worker is a separate container image as indicating that it is part of a separate bounded context. Rather, it is simply a separate container so that the merlin-server can account for the aforementioned process separation concerns. Therefore, each merlin-worker has a direct connection to the merlin database.

The postgres NOTIFY/LISTEN feature is used to NOTIFY workers LISTEN(ing) for newly created simulation jobs. The database trigger emits a notification with a payload containing the simulation revision data. Upon receiving a notification each worker will attempt to claim the simulation job by changing it's simulation_dataset status field to "incomplete". A simulation job is considered taken if this SQL operation is successful. Then the successful worker continues with executing the simulation. If the SQL operation is unsuccessful (e.g. another worker was successful in claiming a job earlier) then the worker handles the failure to claim the job and moves on to attempt claiming other jobs. One is assured that there will be no race conditions due to Postgres' ACID transaction processing.

### Datastores

Aerie's datastores include both relational databases and the file system. A large majority of Aerie's data is considered to be structured data with a small amount of semi/un-structured data. The semi-structured is often in JSON form. A relational database is the appropriate choice when dealing with structured data. Aerie also uses the filesystem to store mission model .JAR files uploaded to Aerie.

[TODO - Elaborate on these considerations]

- Storing that directly and being able to retrieve and filter on that fast at the database layer is important.
- Postgres has JSON and JSONB handling, whereas mariadb supports json only as an alias to `LONGTEXT` field type.
- Design and selection criteria for the db
- Secure connections TLS
- Auth
- Redundancy/scalability
- Application components scalable on their own -> e.g. db scalable on their own
- Historically missions are insufficiently equipped in both the technical ability and resource (time/people/money) to manage large IT infrastructures. As such, it is advantageous for Aerie to minimize the number of database that may require maintenance (backup, updates, provisioning hardware) and to provide administrative infrastructure to carry out these tasks transparently.
- Backups and Migration
- What data is backed up
- Mission model JARs are not. It is expected that the code base which is compiled to the JAR is un configuration management and that a JAR can be reproduced at any time by the user.
- Plans, constraints, simulation resource profiles - all data in the PostgreSQL database should be backed up in case of system failure and migration between Aerie versions.

### Graphical User Interface

[TODO]

### Logging

[TODO]

### Deployment

Aerie deployment is designed to accommodate two user groups; the individual installation on a local machine and the installation on hosted infrastructure.

Each Aerie service is deployed as a Docker container with the deployment orchestrated by the [Docker Compose](https://docs.docker.com/compose/) utility. The Docker Compose utility creates up a single Docker network which enables dependent Docker containers to exchange messages with each other. Each Docker container joins the network and is both reachable by other containers on that network, and discoverable by them at a hostname identical to the container name. Aerie service containers have their IP and port numbers statically assigned within the Docker Compose YAML configuration file.

### Authentication and Authorization

Aerie provides authentication and authorization capabilities via the Common Access Manager. Currently, authentication requests from the Aerie UI are proxied through the aerie-ui-server. It is prudent that Aerie not handle (proxy/store) any credential information, for any duration of time. As a result, Aerie authentication will soon be amended so requests for an authentication token are made directly to a CAM server instance with the Cross-Origin Resource Sharing (CORS) capability enabled.

Authorization is provided by configuring CAM policies. The Aerie GraphQL API Server manages authorization of API access and limits access based on user roles per API field granularity.

### Data Model

#### Datasets

In Aerie, a dataset is a set of data describing several associated concepts. Each dataset can be broken down into three core pieces:

- Profiles
- Spans
- Events

Because a dataset conglomerates several types of data, the actual data within a dataset is spread across several database tables. Several of these tables that may contain many rows of data per dataset are partitioned by dataset ID, allowing for higher efficiency in working with those database tables. The partitions for a given dataset are created and deleted alongside the dataset itself automatically via postgres triggers.

##### Profiles

Profiles describe dynamic values whose behavior is defined in distinct segments. Each profile has a type (real or discrete) governing the dynamics it may exhibit in each segment, a name and an ID. This information is stored in the `profile` table. The actual dynamics and duration of each segment of a profile is stored in the `profile_segment` table. Each segment's start is stored as an absolute offset from the start of the dataset.

##### Spans

Spans describe windows of time via a start offset and duration. Each span must have an assigned type as well as a set of attributes, and may be specified as a child of another span by providing a parent ID.

##### Events

An event graph associated with a dataset may be stored using the `event` and `topic` tables.

#### Simulation Datasets

One of the primary uses of datasets is to store simulation results. Simulation results are stored by placing activity instances in the `span` table, resource profiles in the `profile` and `profile_segment` tables, and an event graph in the `event` and `topic` tables. The `simulation_dataset` table is used to match a simulation up with its associated dataset.

Each row of the `simulation_dataset` table defines all the information about what was input to a simulation resulting in the associated dataset. This includes the versions of the mission model, plan, and simulation input that were used for the simulation run.

An insertion to `simulation_dataset` should only take the simulation ID and offset from plan start from which the dataset should be interpreted. When a `simulation_dataset` row is inserted, a trigger runs to initialize the associated `dataset` row (filling in the `dataset_id` field) and populate the revision columns with the current revision of the associated `mission_model`, `plan`, `simulation` and `simulation_template`. When one of these tables is updated, a separate trigger will automatically mark all associated rows of `simulation_dataset` as canceled by setting the `canceled` column to `true`. Only the `simulation_dataset` representing the up-to-date simulation results should not be canceled.

#### External Datasets

External datasets allow for users of our system to upload precomputed profiles to be associated with a plan. The precomputed profiles are stored in a `dataset` associated with a plan via the `plan_dataset` table.

Similar to inserts on `simulation_dataset`, an insert to `plan_dataset` should only take a plan ID and an offset from the plan's start from which the dataset is to be interpreted. A trigger will automatically insert a row to the `dataset` table, and populate the `dataset_id` of the inserted row, to which precomputed profiles can be added.

### EDSLs

Aerie utilizes a number of EDSLs for parts of the system that require customization of behavior that is more complex than simple option changes and at a different cadence than mission models. We considered using custom DSL's, but the infrastructural work to build in all the capabilities we wanted (listed below in requirements) was prohibitive from a time-to-implement perspective, so we settled on doing EDSLs which use a pre-existing programming language and embeds a domain specific language component therein.

Currently these are Constraints, Scheduling Goals, and Command Expansion. The first of these to come about was Command Expansion, which laid the groundwork for a design that was easily extended to Constraints and Scheduling Goals. This section is written to tell the design/implementation story for all of these EDSLs.

#### Command Expansion Requirements

Command expansion is the process of taking activities in the plan and generating actual spacecraft commands from them. Much of the command expansion conceptual design was evolved from the ideas of the M2020 Scripted Expansion and SIE Sequence Generator systems and the MSL Master Submaster Generator before it.

Conceptually, command expansion is a simple functional map from activities in the map to they're implementing spacecraft commands. Activity → Commands

Due to the desire to abstract away the complexity of spacecraft commands to the simplicity of conceptual spacecraft activities, it is often more complex than a fixed set of commands or even a fixed set of commands with arguments that come from the activity parameters. As such, a more powerful method than simply templating out commands with substitution is desired.

On MSL, this was first captured in part by the Master Submaster Generator that had the entire plan in scope and composed the top level Master sequences and the second tier Submaster sequences. The architecture of that software, however, led it to become overly complex as it was using a visitor pattern over the plan to generate the sequences procedurally, which grew difficult to maintain over time. One of the biggest issues with this system is that documentation was sparse and there was no readily accessible way to check semantic correctness before execution, meaning the development cycle required repeatedly re-deploying and re-executing just to find out that a method being used did not exist or the data structure was different than expected.

On M2020, two systems were built with similar goals - the Scripted Expansion system took user defined python scripts that defined a single function expand that was passed a single activity and then the user called functions (one per spacecraft command) that each inserted a command into the output sequence, while the SIE Sequence Generator ran CM'd TypeScript code that was functional - functions receiving scoped parts of the plan and returning a sequence. Both systems used slightly different API syntax, but both mirrored the resulting commands they output - Scripted Expansions using a functional call structure, and SIE Sequence Generator using an embedded XML syntax that mirrored the resulting RML structure. Both were also composable, allowing user defined sub-functions to abstract away complexity and arbitrary programming constructs use allow the users to use the most intuitive programming constructs for their specific expansion's business logic. One of the huge benefits the Scripted Expansions had over the SIE Sequence Generator was that the API was generated automatically from the command dictionary rather than being built up by the developers.

The concept of the Aerie Command Expansion service took the best parts of all these prior arts. Conceptually, we wanted it to be/use:

- User defined expansions loaded dynamically like M2020 Scripted Expansions
- A functional paradigm like M2020 SIE Sequence Generator
- Scoped to the appropriate activity in the plan like the M2020 Script Expansions
- Intuitive API that mirrored the spacecraft commands it outputs, like both M2020 Scripted Expansions and M2020 SIE Sequence Generator
- An API that was auto-generated from the command dictionary, like M2020 scripted expansions
- Allow arbitrary programming constructs, with a heavy direction toward functional patterns
- We also wanted the authoring of these expansions to be user friendly to write - syntactic and semantic checking at development time and well as API discovery and documentation embedded in the editor.

In additional, we had the standard concerns associated with execution of foreign code:

- Security/Isolation such that expansions can not have access to other expansions or the larger system except where explicitly defined
- Execution limits both on memory used and time to complete
- Protection against unexpected user code inputs/outputs
- Useful error reporting scoped to the code the users can influence

And finally, for performance reasons, we wanted the execution of expansions to be highly parallelizeable.

#### Execution Architecture

Based on these requirements we knew we needed a dynamic programming language with strong editor support for hinting and type-checking, a secure runtime with execution limits, and good support for parallelization. The only well-supported scripting language that currently meets these requirements is TypeScript running in a V8-based runtime - of which the most supported server runtime is NodeJS (other server runtimes are Deno which doesn't yet have the V8 Isolate APIs, and Bun which is actually based on JSCore rather than V8 and is still in very early development). Additionally, TypeScript allows great customization of the exposed user API for us to carefully craft it to a great user experience. Looking forward to needs outside of command expansion (and in an effort to isolate implementation complexity) we designed a generalized library that does this for any functional user code execution. This is the Aerie TS User Code Runner that now underpins all of our EDSLs.

This solution architecture follows:

- A NodeJS runtime
- Secure execution via V8 Isolates and the vm api (CloudFlare has a great article describing how their isolated execution architecture is built on these V8 isolates)
  - These have built in execution limits for both run-time and memory usage
- Programmatic compilation from TypeScript to JavaScript with the TypeScript compiler API that type checks the inputs, outputs, and contents prior to execution to prevent unexpected behavior
  - Also allows type checking against our APIs in web editors (Monaco) out of the box for our UI
- Specialized error curation that scopes any issues in type-checking and execution to the user code (rather than referencing lines of code in auxiliary libraries and the execution structure that the user has no influence over)

And specific to command expansion:

- Light weight parallelization via Worker Threads
- A command API auto-generated from command dictionaries
- A functional API passing the plan scope to a user-defined function and receiving back an array of commands generated from the command API

The selection of a TypeScript EDSL also allows us to have web editors.

#### Command Expansion EDSL Crafting

The specifics of the Command Expansion EDSL was crafted in an effort to make the user code as reflective of the resulting command structure and formats that JPL operations users are already familiar with. This means having commands and arguments be simple function calls named as the command they implement and with arguments that are named and specified with types that reflect the command dictionary definitions for those arguments. We also wanted to enable both the prevalent argument array format as well as a new named argument format which are more clear as to their usage - luckily TypeScript supports this dual format natively.

Below is the command dictionary definition for a single command, the common human readable format used on previous missions, the command EDSL definition for that command and how it would be used:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<command_dictionary>
  <header mission_name="EXAMPLE_DICTIONARY" version="1.0.0.0" schema_version="1.0">
  </header>
  <command_definitions>
    <fsw_command opcode="0xFFFF" stem="UPLINK_DATA_SIZE" class="FSW">
      <arguments>
        <unsigned_arg name="size" bit_length="8" units="byte">
          <range_of_values>
            <include min="0" max="100" />
          </range_of_values>
          <description>How much uplink data is coming</description>
        </unsigned_arg>
      </arguments>
      <categories>
        <module>shell_ctl</module>
        <ops_category>FSW</ops_category>
      </categories>
      <description>A command to communicate uplink data size</description>
      <completion>The data size is received</completion>
      <fsw_specification custom_validation_required="No" command_priority="Nominal" />
      <restricted_modes>
        <prime_string_restriction prime_string_only="No" />
      </restricted_modes>
    </fsw_command>
  </command_definitions>
</command_dictionary>
```

Human Readable form:

```ts
UPLINK_DATA_SIZE 256
```

EDSL definition generated from the command dictionary:

```ts
/** A command to communicate uplink data size **/
function UPLINK_DATA_SIZE(size: U8): UPLINK_DATA_SIZE; // Positional arguments format.
function UPLINK_DATA_SIZE(args: { size: U8 }): UPLINK_DATA_SIZE; // Named arguments format.
```

EDSL usage:

```ts
UPLINK_DATA_SIZE(256); // Positional arguments format.
UPLINK_DATA_SIZE({ size: 256 }); // Named arguments format.
```

With this base for our command EDSL, we wanted a clear way to indicate timing information supported by sequencing for absolute timing, relative timing, epoch-relative timing, and command-complete timing. For this, we leverage tagged template literals where we have a separate one for each. This looks like:

```ts
A`2022-001T00:00:00.000`.UPLINK_DATA_SIZE(256); // Absolute timing.
R`00:00:00.000`.UPLINK_DATA_SIZE(256); // Relative timing to the previous command.
E`00:00:00.000`.UPLINK_DATA_SIZE(256); // Relative timing to a sequence EPOCH.
C.UPLINK_DATA_SIZE(256); // Command complete timing starting immediately after the prior command completes.
```

Putting all of this together, a user defined command expansion looks like:

```ts
export default function ({ activityInstance: ActivityType }): ExpansionReturn {
  return [C.UPLINK_DATA_SIZE(activityInstance.attributes.arguments.dataSize)];
}
```

#### Other EDSLs

With a working EDSL for command expansion, we saw great opportunity to do similar refactor of our scheduling and constraint structures from JSON ASTs to more user-friendly APIs with similar UI benefits. These cases were slightly different though as they required high volume iterative execution where sending the full context for execution from our main Java process to the NodeJS process the code runner executes in would be prohibitive performance-wise. If you take that and the pre-existing support for the JSON ASTs, we decided to go the route of having the EDSL generate a JSON AST that can then be parsed and iteratively executed in the Java Process. So the user code execution is simply doing a transformation from EDSL to a JSON AST in these cases.

## Simulation and Modeling Design

The Aerie approach to simulation aims to support both activity plan simulation (APGen) and sequence simulation (SeqGen). To do this the Aerie simulation architecture must build upon a general description of the effects posted by either activity modelling effects or sequences. Please see the document on [The Merlin Interface](./../../mission-modeling/advanced-the-merlin-interface) for detailed information about how Aerie accomplishes this.

### Mission Model Interface

[TODO]

#### Event Graph

[TODO]

#### Resource Profiles

[TODO]

## Constraints

When analyzing a simulation's results, it is useful to detect time windows where certain conditions are met. An Aerie constraint is a condition based on the simulated activities and resources profiles which must hold true for some period of time. If a constraint does not hold true at any point within the specified time period of interest, the constraint is a violation.

A Constraint is defined as an expression (expression of expressions) which operate on resource profiles and activity instances. Allowed expressions are defined by the Aerie constraint grammar. Currently, the grammar is directly represented as specific types of nodes which are used to construct an expression tree.

In the Aerie constraint AST, the internal nodes represent the constraint expression operators, while the leaf nodes represent the operands. For example, operator nodes enable expressions such as 'or', 'and', 'less than', 'greater than', while the operands are simulated resource profiles and activity instances.

The AST is encoded as a JSON structure where each node in the AST has at minimum a type field specifying the expression's type (operator or operand). Complex constraint definition are built up by composing additional nodes. See our [constraints documentation](../../constraints/examples) for complete examples.

## Meta-Programming (Annotations Processing)

Aerie uses a meta-programming approach to generate additional source files and documentation. Meta-programming reduces the requirement for a mission modeler to write a range of (de)serialization and state injection code for various Aerie data objects. Aerie uses meta-programming for the following purposes:

- Generate (de)serialization classes for Activity definitions for transportation across the application boundary.
- Facilitate dependency injection for Activity parameters.
- Expose:
  - Activity type
  - Activity effect model
  - Activity parameter (de)serialization and value injection
  - Activity parameter value validation
  - Mission model entry point
  - Mission model configuration
  - Activity types defined within the mission model
  - Activity dependency injection - initializing an activity from its stored representation.

For many types, a reasonable serialization scheme can be inferred via reflection. Merlin intends to provide a reflective mapper as a simple default choice for mission modelers. Custom annotation derived mappers shall remain as the recommended option for optimization purposes or for greater control over the serialized data.

Aerie chose to use Java's annotations processing mechanism. Unlike a mechanism such as reflection which operates at runtime, annotations processing automatically generates Java code which is then compiled. This compile time generation allows for the compile time type checking and results in code which can be debugged at runtime.

[TODO]

- A handy and powerful technique for generating additional source files during compilation.
  - Source files can be any type of files (Java files, documentation, resources, and etc).
  - It can only be used to generate new files, not to change existing ones.

## Scheduling Design

Just as a human operator places and edits activities in a mission plan, so too can an algorithmic agent can make automated decisions about activity plan editing. An automated scheduling agent enables missions to make a large volume of plan mutations and perform the complex evaluations as to how well such mutations achieve a mission's goals.

In Aerie the scheduling agent "Automated Scheduler" exists as a separate entity and makes queries and mutation against the Aerie API. As shown in the Figure below, an Aerie developed and maintained automated scheduler is a part of the standard Aerie deployment. The Aerie Automated Scheduler makes queries of simulation results, constraint evaluations, and makes plan mutations via the Aerie API. This loose coupling is the same as any third party entity which may query the Aerie API gateway. As a result, a mission can choose to forgo the Aerie Automated Scheduler and implement their own scheduler and scheduling algorithm, which makes use of the same Aerie API.

Previous activity planning and simulation systems chose to embed scheduling logic within the mission model code base. Such tight coupling of scheduling logic with the mission model code introduced particularly burdensome restrictions. The loose coupling of the Aerie design alleviates these burdens and is characterized by the following aspects:

- Expressivity - restrictions on expressivity (using other programming paradigms to develop scheduling algorithms and evaluate scheduling rules)
- Extensibility - extensibility (definition of new constraint concepts without having to modify any part of Aerie or a mission model)
- Maintainability - disconnect the mission model and scheduling editing CM process
- Process independence/async - run on different infrastructure providing performs, and more dynamic execution workflows

import c4SchedulingComponent from './assets/c4-scheduling-component.png';

<figure align="center">
  <img alt="Scheduling Component" src={c4SchedulingComponent} width="400" />
  <figcaption>Figure 4: The Aerie Scheduling Component</figcaption>
</figure>

When executing the Automated Scheduler is likely to make many calls to the Aerie API. The Automated Scheduler will sensibly batch API calls to reduce unnecessary communication round trips. A scheduler will need to be able to make the following requests of the Aerie API:

- Query for activity instances in a plan
- Add, edit, delete activity instance from a plan
- Simulate an activity plan for some duration from some start time
- Query simulated resource profiles
- Add/edit/delete constraints for a plan
- Query constraint windows for a plan
- Submit a constraint definition for its windows for a plan

## Appendix

### A - The C4 Model

The architectural diagramming approach taken in this document follows the [C4 Model](https://c4model.com/) for visualizing and discussing software architecture. This approach abstracts a software system into roughly four level, Context, Containers, Components, and Code. A brief overview of the first three levels of abstraction is given below to help the reader of this document better understand what is being communicated in the various diagrams.

1. The Context diagram shows the software system (Aerie) in its broadest scope.

   **Scope:** A single software system.<br />
   **Primary elements:** The software system in scope.<br />
   **Supporting elements:** People (e.g., users, actors, roles, or personas) and software systems (external dependencies) that are directly connected to the software system in scope. Typically, these other software systems sit outside the scope or boundary of your own software system, and you don’t have responsibility or ownership of them.<br />
   **Intended audience:** Everybody, both technical and non-technical people, inside and outside of the software development team.

2. The Container diagram shows the high-level shape of the software architecture and how responsibilities are distributed across it. It also shows the major technology choices and how the containers communicate with one another. A container is a separately runnable/deployable unit (e.g., a separate process space) that executes code or stores data.

   **Scope:** A single software system.<br />
   **Primary elements:** Containers within the software system in scope.<br />
   **Supporting elements:** People and software systems directly connected to the containers.<br />
   **Intended audience:** Technical people inside and outside of the software development team; including software architects, developers and operations/support staff. Notes: This diagram says nothing about deployment scenarios, clustering, replication, failover, etc.

3. The Component diagram specifies the "components" which comprise a Container, what each of those components are, their responsibilities and the technology/implementation details.

   **Scope:** A single container.<br />
   **Primary elements:** Components within the container in scope.<br />
   **Supporting elements:** Containers (within the software system in scope) plus people and software systems directly connected to the components.<br />
   **Intended audience:** Software architects and developers.
